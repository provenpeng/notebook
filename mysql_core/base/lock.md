# 锁

数据库锁的初衷是处理并发问题。作为多用户共享资源，当出现并发访问时，数据库需要合理的控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

## 全局锁

全局锁会对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法：**Flush tables with read lock(FTWRL)**，可以让整个库处于只读状态，之后其他线程的以下语句会被阻塞：

- 数据更新语句（增删改）
- 数据定义语句（建表、修改表结构）
- 更新类事务的提交语句

**全局锁的典型使用场景是，做全库逻辑备份**，缺点：

- 如果在主库上备份，那么备份期间都不能执行更新，业务基本上就得停摆；
- 如果在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

但是不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是不一致的。

其实在可重复读隔离级别下开启一个事务是能够拿到一致性视图的。

官方自带的逻辑备份工具是mysqldump，当其使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，这个过程中数据可以正常更新。

**一致性读是好，但前提是引擎要支持这个隔离级别**，对于不支持事务的引擎，就需要FTWRL命令了。因此，**single-transaction方法只适用于所有的表使用事务引擎的库**，如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。

为什么不建议set global readonly=true的方式，而建议FTWRL呢？

1. 在一些系统中，readonly的值会被用来做其他的逻辑，比如判断一个库是主库还是备库。因此修改global变量的方式影响面大，不建议使用；
2. 在异常处理机制上有差异，如果执行FTWRL命令后由于客户端异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新状态，而将整个库设置为readonly后，如果客户端异常，数据库会一直保持readonly状态，风险较高。

业务的更新不只是增删改，还可能是修改表结构的操作，不论是哪种方法，一个库被全局锁上后，你要对里面任何一个表的字段做操作，都是会被锁住的。

## 表级锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### 表锁

语法是**lock tables ... read/write**，与FTWRL类似，可以使用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

lock tables语法除了会限制别的线程的读写，也限定了本线程接下来的操作对象。例如：某线程A执行了：

```sql
lock tables t1 read, t2 write;
```
那么其他线程写t1，t2的语句都会被阻塞。同时线程A在执行unlock tables之前，也只能执行读t1，读写t2的操作，连写t1都不允许，自然也不能访问其他表。

一般不用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大

### MDL（元数据锁）

MySQL5.5版本中引入了人MDL，不需要显式使用，在访问一个表的时候会被自动加上，作用是保证读写的正确性。

当对一个表做增删改查的时候，加MDL读锁，当要对表结构做变更操作时，加MDL写锁：

- 读锁之间不互斥，因此可以有多个线程同时对一个表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证表结构变更操作的安全性，因此，如果有两个线程要同时给一个表加字段，其中一个要等待另一个执行完才能开始执行。

