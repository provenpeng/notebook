# 主从数据同步

## 读写分离

redis是采用主从库的模式，以保证数据副本的一致。主从库之间采用读写分离的方式。

- **读操作**：主库从库都可接收
- **写操作**：只能主库接收，然后主库将操作同步给从库

为什么读写分离：如果多个对于同一个key的写操作，都发送到不同的实例，那么各个实例的数据就会不一致，读取该key时，就可能读取到旧值。如果非要保证一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，会带来巨额开销。

## 主从库间第一次同步

当启动了多个redis实例，就可以用 **replicaof** 命令形成主从库关系，之后会按照三个阶段完成数据的第一次同步。

1. 从库和主库建立连接，并告诉主库即将进行同步，主库回复确认后，同步即可开始。
   - 从库给主库发送**psync**命令，表示要进行数据同步，主库根据以下两个参数来启动复制
      - runID：redis实例的唯一id（实例启动时生成的随机数），第一次主从复制时，因不知道主库的runID，所以将runID设为“？”。
      - offset：此时设为-1， 表示第一次复制。
   - 主库收到psync命令时，会用**FULLRESSYNC**响应命令，表示第一次复制采用的**全量复制**，带上两个参数，从库收到后会记录：
       - runID：主库ID
       - offset：主库目前的复制进度。
  
2. 主库将所有数据给从库，从库收到数据后，在本地完成数据加载。
   - 主库执行bgsave生成RDB文件并发给从库
   - 从库收到RDB文件，清空当前库，然后加载RDB文件
   - 主库将数据同步给从库期间，不会阻塞，可以接收新请求，但是新请求不会记录到刚刚生成的RDB文件，而是记录在**replication buffer**内存中。

3. 主库完成RDB文件的发送后，会把此时的replication buffer中的修改操作发给从库，从库执行这些操作，这样从库就实现同步了。

主从库全量复制完成后，它们间会维护一个网络连接，主库会通过这个连接将后续收到的命令操作同步给从库，这个过程也称为**基于长连接的命令传播**，避免了频繁建立连接的开销。

## 主从级联模式

如果从库数量很多，且都要和主库全量复制，会导致主库频繁fork子进程生成RDB文件，fork操作本身会造成阻塞，RDB文件的传输会占用带宽，导致主库压力过大，此时采用 “主-从-从” 模式，将主库生成和传输RDB文件的压力，以级联的方式分散到从库上。

可以手动选择一些从库A，用于级联其他从库，然后可以再选择一些从库B，在B上执行如下命令，让B与A建立主从关系：

```bash
replicaof A从库的IP 6379
```

这样主库的压力就被从库A们分担了

## 增量复制

如果主从库网络断连，会采用增量复制的方式继续同步：主库将断连期间收到的命令同步给从库。过程如下：

1. 主从库断连后，主库将断连期间收到的写操作命令，写入replication buffer，同时也会写入**repl_backlog_buffer**这个**环形**缓冲区。主库记录自己写到的位置**master_repl_offset**，从库记录自己已经读到的位置**slave_repl_offset**。
2. 主从连接恢复后，从库给主库发送psync命令，并将自己当前的slave_repl_offset发给主库，主库会判断和自己写位置的差距，将相差的部分同步给从库。

注意：由于repl_backlog_buffer是环形缓冲区，写满后会继续写入，导致覆盖。如果从库读取比较慢，还未读的操作就被主库的写操作覆盖了，会造成主从不一致，导致触发全量复制！！

解决建议：调整**repl_backlog_size**参数，大小设为所需缓冲空间大小 \* 2，缓冲空间大小 = 库写入命令速度 \* 操作大小 - 主从库间网络传输命令速度 * 操作大小。如果并发量非常大可以设为缓冲区大小的4倍，再不行的话，就建议使用切片集群了。
