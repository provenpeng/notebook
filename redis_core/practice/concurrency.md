# 并发访问控制

在使用Redis时，不可避免的会遇到并发访问的问题，Redis提供了两种方法，分别是加锁和算子操作。

## 一、原子操作

原子操作是指执行过程保持原子性的操作，而原子性操作执行时不需要加锁，实现了无锁操作，既能保证并发控制，还能减少对系统并发性能的影响。

### 1. 并发访问中需要对什么进行控制

并发访问控制是指：对多个客户端访问同一份数据的过程进行控制，以保证任何一个客户端发送的操作在Redis上的执行时具有互斥性。主要是针对数据修改操作。当客户端数据需要修改时，基本流程分为两步：

1. 客户端先把数据读到本地，在本地进行修改；
2. 客户端修改完数据后，再写回Redis。

该过程叫做“读取-修改-写回”操作，简称RMW操作，RMW操作涉及的代码（临界区）需要以原子性的方式执行。

如果用加锁的方式来控制临界区代码的执行情况：

```C
LOCK()
current = GET(id)
current--
SET(id, current)
UNLOCK
```

可以保证互斥性，但是**加锁也会导致系统并发性能降低**。

### 2. Redis的原子操作

redis的原子操作采用了两种方法：

1. 把多个操作在redis中实现成一个操作，也叫单命令操作；
   
   Redis是单线程串行处理客户端命令的，在执行某个命令操作时，其他命令无法执行，相当于说命令操作是互斥执行的。

   如：使用INCR/DECR对数据进行**增值/减值**操作

2. 把多个操作写到一个Lua脚本中，以原子性的方式执行单个Lua脚本。
   
   如果要执行的操作不是简单的增减数据，而是有更加复杂的判断逻辑或者其他操作，就不能用简单的单命令操作能实现的了。

   可以将需要原子执行的操作编写到一个Lua脚本中，然后使用Redis的EVAL命令来执行脚本，从而保证这些操作的互斥性。

建议：**在编写Lua脚本时，要避免把不需要做并发控制的操作写入脚本中**。否则导致Redis执行脚本的时间增加，降低并发性能。

## 二、Redis实现分布式锁

在分布式系统中，当有多个客户端需要获取锁时，需要分布式锁。此时锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。

redis本身可以被多个客户端共享访问，同时读写性能高，可以应对高并发的锁操作场景。

### 1. 单机锁和分布式锁的联系和区别

对于单机上运行的多线程程序来说，锁本身可以用一个变量表示：

- 变量值为0时，表示没有线程获取锁；
- 变量值为1时，表示已经有线程获取到锁了。

和单机上的锁类似，分布式锁同样可以用一个变量实现，加锁和释放锁的逻辑和单机上类似：加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设为0，表示客户端不再持有锁。

不同之处在于：**在分布式场景下，锁变量需要由一个共享存储系统来维护，相应的，加锁和锁释放的操作就变成了读取、判断、设置共享存储系统中的锁变量值**。

这就要求实现分布式锁时：

1. 加锁、释放锁的过程涉及到的多个操作要保证原子性
2. 要保证共享存储系统的可靠性，进而保证锁的可靠性

### 2. 基于单个Redis节点实现分布式锁

将锁变量名作为Redis的Key，锁变量值作为Redis的Value，这样一来，Redis就能保存锁变量了，客户端也可以通过Redis命令来实现锁操作

为了保证原子性，加锁/释放锁可以使用SETNX/DEL命令实现：

```C
// 加锁
SETNX lock_key 1
// 业务逻辑
DO THINGS
// 释放锁
DEL lock_key
```

潜在风险：

1. 某个客户端加锁后，操作共享数据时异常，导致没有释放锁
   
   解决方案：给锁变量设置一个过期时间

2. 客户端A执行SETNX加锁后，客户端B执行了DEL释放锁，此时A的锁就被误释放了，如果客户端C正好在申请锁，就会成功
   
   解决方案：**需要能区分来自不同客户端的操作**，在加锁时，让每个客户端给锁变量设置一个唯一值（标识当前客户端），释放锁时，客户端需要判断当前锁变量是否和自己的唯一标识相等。Redis中实现方法如下：

   ```bash
   # 加锁
   SET lock_key unique_value NX PX 10000
   # 其中unique_value是客户端唯一标识，PX 10000表示lock_key会在10s后过期
   ```

   使用Lua脚本释放锁（保证原子性）

   ```LUA
   // 释放锁 比较unique_value是否相等，避免误释放
   if redis.call("get",KEYS[1]) == ARGV[1] then
      return redis.call("del",KEYS[1])
   else
      return 0
   end
   ```

   调用Lua脚本即可释放锁

   ```Bash
   redis-cli  --eval  unlock.script lock_key , unique_value
   ```

### 3. 基于多个Redis节点实现高可靠的分布式锁

单节点Redis实现的分布式锁，如果Redis宕机了，就会影响整个业务的正常执行，因此在实现分布式锁时要保证锁的可靠性。

Redis的开发者提出了Redlock分布式锁算法。

基本思路：让客户端和多个独立的Redis实例依次请求加锁，如果客户端能和半数以上的实例成功的完成加锁操作，就认为成功的获取到了锁，否则加锁失败。这样即使单个Redis实例故障，锁也不会丢失。

Redlock算法的执行步骤：

1. 客户端获取当前时间
2. 客户端按照顺序依次向N个redis实例执行加锁操作
   
   这里的加锁操作和单实例上的加锁操作一样，使用SET命令，带上NX，EX/PX选项，以及带上客户端唯一标识，还要给加锁操作设置一个超时时间（防止某个redis实例宕机卡住），加锁操作的超时时间需要远远小于锁的有效时间，一般也就设置几十毫秒。

3. 一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁的总耗时。
   
   客户端满足以下条件才算加锁成功：

   - 客户端从超过半数（>= N/2+1）的Redis实例上成功获取到了锁
   - 客户端获取锁的总耗时没有超过锁的有效时间
   
   满足以上2条件后，重新计算这把锁的有效时间（锁的最初有效时间-客户端获取锁的总耗时），如果有效时间来不及完成共享数据的操作了，就可以释放锁，以免还没完成数据操作，锁就过期了。

   如果木满足以上两个条件，客户端要向所有的Redis实例发起释放锁的操作。

在Redlock算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的Lua脚本就行了。

所以在实际的业务应用中，如果想要提升分布式锁的可靠性，就可以通过Redlock算法实现。

## 三、Redis能实现事务机制？

事务的的执行包含三个步骤，Redis提供了MULTI、EXEC两个命令来完成这三个步骤：

1. 客户端使用MULTI命令显式的开启一个事务
2. 客户端把事务中本身要执行的具体操作发送给服务端，Redis它们暂存在一个命令队列中，并不会立即执行
3. 客户端向服务器端发送EXEC命令，让数据库实际执行第二部中发送的具体操作。

### 1. Redis的事务机制能保证ACID中哪些属性？

#### 原子性

当事务正常执行，没发生任何错误，那么MULTI和EXEC配合使用，就可以保证完成多个操作。

但是事务执行过程中发生了错误时，会有三种情况：

1. 执行EXEC命令前，客户端发送的操作命令本身就有错误，在命令入队时被Redis实例判断出来了
   
   这种情况下，Redis会报错并且记录下这个错误，此时还能继续提交命令操作，但是执行EXEC后，Redis就会拒绝执行所有提交的命令操作，返回事务失败，所有命令都没有被执行，能保证原子性

2. 事务操作入队时，命令和操作的数据类型不匹配，但Redis实例没有检查到错误
   
   在Redis执行完EXEC命令后，执行到错误事务操作时，就会报错，但还是会把正确的命令执行完，这时事务的原子性得不到保证。因为Redis没有提供回滚机制，只提供了DISCARD命令主动放弃事务执行，把暂存的命令清空，起不到回滚效果。

3. 在执行事务时，Redis实例发生了故障，导致事务执行失败
   
   如果开启了AOF日志，那么只有部分的事务操作被记录到了AOF日志中，需要使用redis-check-aof工具检查AOF日志文件，将已完成的事务操作从AOF去除，这样再用AOF恢复实例后，事务操作不会再被执行，保证了原子性

   如果没开启AOF日志，保证不了原子性

### 一致性

同样分三种情况来看：

1. 命令入队就报错
   
   事务本身就会放弃执行，可以保证数据库的一致性

2. 命令入队时没报错，实际执行报错
   
   有错误的命令不会被执行，正确的命令可以被执行，也不会改变数据库的一致性

3. EXEC命令执行时实例发生故障
   
   - 没有开启RDB、AOF，故障重启后就没数据了，数据库是一致的
   - 使用了RDB快照，RDB快照不会在事务执行时执行，所以用RDB快照恢复时，数据库里的数据是一致的
   - 使用了AOF日志
     - 如果事务操作还没被记录到AOF，实例就故障，用AOF恢复的数据库数据是一致的
     - 如果只有部分操作被记录到了AOF日志，可以用redis-check-aof清除掉，数据库恢复后也是一致的

### 隔离性

事务的隔离性保证，会受到和事务一起执行的并发操作的影响。

1. 并发操作在EXEC命令前执行，此时，隔离性需要使用**WATCH**机制来实现，否则无法保证隔离性
   
   > WATCH机制的作用是，在事务执行前，监控一个或多个key的值变化情况，当事务调用EXEC命令执行时，WATCH机制会先检查监控的key是否被其他客户端修改了，如果修改了，就放弃事务实行，避免事务的隔离性被破坏。然后客户端可以再次执行事务，此时如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性得到了保证

2. 并发操作在EXEC命令后执行
   
   因为Redis使用单线程执行命令，而且，EXEC命令执行后，Redis会保证先把命令队列中的所有命令执行完，所以这种情况下，并发操作不会破坏事务的隔离性。

### 持久性

因为Redis是内存数据库，所以，数据是否持久化保存完全取决于Redis的持久化配置模式。

就算RDB、AOF都用上，也一样会有丢数据的情况，持久性都得不到保证
